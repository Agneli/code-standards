<!-- ### CROSS-BROWSER + PERFORMANCE SECTION ### -->

<section id="performance">

	<div class="intro has-icon">
		<img class="icon" src="img/layout/icon-curly.png" alt="{}" />
		
		<h1>Performance</h1>

		<p>Enquanto nós continuamos a empurrar os limites do que é possível fazer na web, continua sendo importante que uma página da web deve ser usada com o mínimo de esforço ou tempo de espera. A seguir algumas explicações sobre como páginas web podem ser otimizadas para continuar a deixar todos os públicos felizes.</p>
	</div>
	
	<h3>Otimizar Entrega do CSS e JavaScript</h3>

	<p>Segue algumas otimizações que devem ser feitas para servir CSS e JavaScript em produção:</p>
	
	<ul>
		<li>Seguir as diretrizes de performances do <a href="http://developer.yahoo.com/performance/">Yahoo</a>
		<li>Reduza imagens usando o <a href="http://developer.yahoo.com/yslow/smushit/">smush.it</a>. Também use o <a href="http://developer.yahoo.com/yslow/">YSlow</a> que reduz automaticamente todas as imagens para você.</li>
		<li>Configure o cache dos cabeçalhos apropriadamente.</li>
		<li>Considere um subdomínio sem cookies para static assets</li>
		<li>Evite blocos em linha de &lt;script&gt;.</li>
		<li>CSS deve estar localizado no <code>&lt;head></code> do documento, JavaScript deve estar logo antes da tag <code>&lt;/body></code>.</li>'
		<li>CSS e JavaScript devem estar minificados no lado do servidor. A maioria das pessoas usam o <a href="http://developer.yahoo.com/yui/compressor/">YUI Compressor</a> para isso.</li>
		<li>Ambos devem ser servidos <a href="http://code.google.com/speed/page-speed/docs/payload.html#GzipCompression">usando gzip</a></li>	
		<li>CSS devem ser concatenados juntos. Obviamente só pode ser feito com arquivos que compartilham o mesmo tipo de mídia (e.g. screen ou print). O objetivo principal é reduzir o número de conexões HTTP com dependências durante o carregamento da página.</li>
		<li>JavaScript deve ser concatenado. Enquanto um gerenciador de script ajax seria o ideal (similar ao YUI 3 Loader), é mais complicado de se implementar. No seu lugar, eu recomendo um download singular da maior parte do script usado no site. (Claro, cache apropriado deve ser usado para manter o arquivo de forma razoável).</li>
		<li>Concatenação e minification normalmente ocorrem durante um processo de build automatizado, ao empacotar o código para implantação no palco ou de produção. Muitos usam ferramentas como <a href="http://ant.apache.org/">Ant</a> ou <a href="http://maven.apache.org/">Maven</a>.</li>
		<li>Evite blocos <code>&lt;script></code> em linha com o HTML. Eles bloqueiam a renderização e são bastante devastadores com o tempo de carregamento de página.</li>
	</ul>
	
	<h3>Otimize a execucão do JavaScript</h3>

	<p>Durante o carregamento da página, é comum alguns scripts esperarem para executar, mas você pode priorizar isso. Esta ordem prioriza com base na resposta do usuário:</p> 

	<ol>
		<li>Scripts que mudam visivelmente a natureza da página precisam ser carregadas primeiro. Isso incluí qualquer ajuste de fonte, layout de caixa, ou IE6 pngfixes.</li>
		<li>Inicialização do conteúdo da página</li>
		<li>Cabeçalho da página, navegação superior e inicialização do rodapé</li>
		<li>Anexar manipuladores de eventos</li>
		<li>Omniture, Doubleclick, e outros scripts de terceiros</li>
	</ol>

	<h3>Alavancagem dos CSS Sprites</h3>

	<p>CSS Sprites normalmente tem uma porção de imagens mescladas juntas em um arquivo único de imagem. Cada parte é revelada usando CSS <code>background-position</code>. Alguns normalmente seriam assim:</p>
	
	<textarea class="brush:css">
	a.expandbox { 
		display: block;
		width: 75px;
		height: 15px;
		text-indent: -999px;
		overflow: hidden;
		background: url(../img/sprite.png) no-repeat -50px -5px;
	}
	</textarea>

	<P>É muito comum o uso de sprites para estados de <code.:hover</code>. No caso, será algo assim:</p>
	
	<textarea class="brush:css">
	a.expandbox:hover { background-position: -50px -20px; }
	</textarea>
	
	<p>Usando CSS sprites você reduz o peso total da página e também o número de conexões HTTP, acelerando o carregamento da página. <a href="http://css-tricks.com/css-sprites/">Mais sobre técnicas gerais e uma visão sobre sprites.</a> Isto é apenas uma melhor prática para se fazer,  sempre que puder, o uso de CSS Sprites.</p>

	<p>Muitos desenvolvedores usam um sprite verticalmente-orientado para o sprite primário. Este sprite vertical deve ter <strong>menos do que ou igual a 100px de largura</strong> (e alto), conter ícones que normalmente são colocadas junto ao texto, tais como balas de ítem de lista ou ligue para links e botões de ação. Yahoo usa <a href="http://l.yimg.com/a/i/ww/sp/pa-icons3.gif">poucos como este</a>.</p> 

	<p>A única consideração é que não fazer sprites muitos largos, algo entre 1000px em qualquer direção vai acabar usando uma quantidade considerável de memória. Leia mais em <a href="http://blog.vlad1.com/2009/06/22/to-sprite-or-not-to-sprite/">quando usar sprites e o uso de memória</a>, e para mais dicas gerais e técnicas na criação de sprites, veja o <a href="http://blog.mozilla.com/webdev/2009/03/27/css-spriting-tips/">Mozilla Dev Blog</a>.</p>

	<h3>Formato de imagens</h3>

	<p>Aqui os quatros principais formatos de imagens que devem ser usados, detalhes abaixo:</p>
	
	<dl>
		<dt>JPEG</dt> 
		<dd>Ele será responsável por todas as imagens fotográficas, tal como imagens promocionais da homepage e categoria, ou qualquer imagem com um número muito alto de cores.</dd>

		<dt>PNG24</dt> 
		<dd>
			<p>Este formato é facilmente acessível em Photoshop, gera imagens de alta contagem de cores e apoia suporte a opacidade graduada por pixel. Relativamente, é um formato pesado, medindo em kilobytes. Este é apenas o único formato que o IE6 precisa executar um pngfix para funcionar. Quando projetos precisam dar suporte ao IE6, nós usamos o script <a href="http://www.dillerdesign.com/experiment/DD_belatedPNG/">DD_belatedPNG</a> (Um pngfix que corrige o problema quando PNG24's aparece com um cinza ou um azul claro fundo no IE6. Eles nem sempre são compatíveis com background-position).</p>

			<p>E muitos casos você pode usar um fallback em GIF para o IE6 no lugar do PNG24. Isso será mais evidente se quaisquer sprites precisam ser feitas em PNG24. Todos os pngfixes são muitos lentos e caros, por isso é melhor evitá-lo.</p>
		</dd>

		<dt>PNG8</dt>
		<dd>
			<p>A surpreendente diversidade de cores pode ser capturada dentro das 256 cores, por isso vale a pena tentar PNG antes de JPG. PNG também é muito mais compacto que o GIF. Este formato permite opacidade graduada em quase todos os navegadores, mas no IE6 os pixels semi-opacos são apenas mostrado 100% transparente. Em muitos casos isso é suficiente. Ele também não exige um pngfix para ser executado, por isso é otimizado para velocidade.</p>

			<p>Photoshop não pode produzir esses arquivos semi-opacas corretamente, mas o Fireworks pode.<a href="http://www.sitepoint.com/blogs/2007/09/18/png8-the-clear-winner/">http://www.sitepoint.com/blogs/2007/09/18/png8-the-clear-winner/</a></p>
		</dd>
		
		<dt>Transparent GIF 89a</dt>
		<dd>
			<p>GIF 89a oferece a flexibilidade da transparência e amplo suporte dos navegadores, mas as restrições de nenhuma opacidade graduada, nem uma profundidade acima de 256 cores. Em nossa experiência, profundidade de 64 cores fornecem boa qualidade em miniaturas, e mantem o tamanho do arquivo comparativamente muito pequeno.</p>

			<p>Todas baixa contagens de cores em imagens como ícones ou gráficos temáticos devem ser feitos em PNG8, como é mais eficiente em termos de tamanho deste quatro. PNG8 é a nossa principal recomendação para a maioria dos gráficos em sites.</p>
		</dd>
	</dt>

	<p>Detalhes sobre o formato PNG, suporte dos navegadores, e os prós e contras <a href="http://calendar.perfplanet.com/2010/png-that-works/">é abordado neste artigo</a>.</p>

	<p>Para mais otimização destes formatos, use o <a href="http://developer.yahoo.com/yslow/smushit/">Yahoo's Smush.It</a>, ele irá revelar como eles podem ser menores.</p>
	
	<h3>Cache</h3>

	<p>Para conteúdo estático, o navegador deve cachear o arquivo localmente, enquanto for razoável.O conteúdo que deveria ter cache definir no futuro inclui coisas como:</p>
	
	<ul>
		<li>arquivos CSS e JavaScript</li>
		<li>imagens de produtos</li>
		<li>gráficos temáticos</li>
		<li>favicon.ico</li>
		<li>flash .swf's e vídeos</li>
		<li>imagens promocionais (leve cache provável)</li>
	</ul>

	<p>Para um melhor cache, alavanque o <code>Expires http header</code>.
	
	<p>For the best caching, leverage the <code>Expires http header</code>. This is a far future Expires header, telling the browser that this response won't be stale until April 15, 2015.</p>
	
	<pre>Expires: Thu, 15 Apr 2015 20:00:00 GMT</pre>
	
	<p>If your server is Apache, use the <code>ExpiresDefault</code> directive to set an expiration date relative to the current date. This example of the <code>ExpiresDefault</code> directive sets the Expires date 1 year out from the time of the request.</p>
	
	<pre>ExpiresDefault "access plus 1 year"</pre>
	
	<p><code>Expires http header</code> should be set to a value between one month from present to a year (far future) from present. Caching only applies to that exact URL, so a change in the filename of any asset will start a fresh copy. Many developers use a build process to add a version number or timestamp to their assets, one example of this is the HTML5 Boilerplate. Each subsequent build will start a brand new cached version allowing you to use far future cache dates without worry. <a href="http://code.google.com/speed/page-speed/docs/caching.html#LeverageBrowserCaching ">Google has a lot more detail on browser caching</a>.</p>
	
	
	<h3>Shard resources across domains</h3>
	
	<p>Static content should certainly be served from a domain different than the one that serves HTML. This is optimal so that there are <a href="http://developer.yahoo.com/performance/rules.html#cookie_free">no extra cookies headers on all static content requests</a>. It's also much easier to write caching rules for the entire domain. (Also any subdomains of the current domain will inherit domain cookies, so it's worth using a completely new domain).</p>
	
	<p>However with enough assets (especially images) the number of requests grows enough to slow down the load of the page. Many browsers have a low constraint of how many assets they will download simultaneously per domain. (In IE6 and 7, it's only two). In this case, we can serve the assets from multiple subdomains such as:</p>
	
	<ul>
		<li>static1.otherdomain.com</li>
		<li>static2.otherdomain.com</li>
		<li>static3.otherdomain.com</li>
	</ul>

	<p><a href="http://code.google.com/speed/page-speed/docs/rtt.html#ParallelizeDownloads">More information on domain sharding on Google Speed</a></p>
	
	
	<h3>Avoid IFRAMEs</h3><!-- like the plague -->
	
	<p>Iframes are the most costly element to add to a given page. They block the page from firing the onload event until they are complete. Sometimes they are useful to let another agency handle tracking scripts. For example the Doubleclick floodlight tag is an iframe, and the admin can add tracking pixels into it from their dashboard. In any case where an iframe is added, it should be appended to the DOM dynamically after window onload has fired. <a href="http://developer.yahoo.com/performance/rules.html#iframes">More detail at Yahoo's Performance site.</a></p>
	
	
	<h3>3rd Party Integration</h3>
	
	<h4>Omniture</h4>
	
	<p>We recommend to add the Omniture JavaScript code to the DOM using JavaScript after the page has loaded (either a DOM ready event or window's load event). Using this technique, there is no external domain script dependency, which can slow down (and potentially hang) a page load.</p>
	
	
	<h4>Flash</h4>
	
	<p>Backup HTML content should be in place of the flash in all cases to maximize SEO value. For XML-driven flash, the backup HTML content should be leveraging the exact same XML file, to ensure data consistency.</p>
	
	<p>All replacements should be done using SWFObject but without inline script tags. SWFObject initialization should fire after the DOM Ready event. Minimum player version should be set to minimum v9, to ensure AS3 compatibility.</p>
	


		<h2 id="browserperformance">Cross-Browser Performance Strategy</h2>
		<p>There are two major truths when it comes to in-browser experience:</p>

		<ol>
			<li>Everyone wants the most responsive experience possible.</li>
			<li>Everything added to the page slows it down.</li>
		</ol>

		<p>So with these two facts of life, what steps do we need to take so everyone is happy?</p>
	

	<h3>Create success metrics with the client</h3>

	<p>These should be customized to your client and project and done before the wireframing phase. These goals should be reasonable from a technical POV, as well as testable.</p>
	
	<strong>Some goals that would be appropriate:</strong>
	
	<ol>
		<li>The slowest browser supported must go from an empty cache to fully loaded and initialized within 5 seconds.</li>
		<li>Hover states (and other 'instant' changes) should respond within 100ms.</li>
		<li>Animations should appear smooth, with jumpiness occurring &lt; 15% of the time (across all browsers).</li>
	</ol>
	
	<p>For load-time based goals, it's important to define the benchmark system. Something like <a href="http://www.webpagetest.org/">PageTest</a> is a good option. Additionally, goals may be defined for multiple pages, for example: the two most popular landing pages (e.g. homepage and support).</p>
	
	<p>If the client has more aggressive goals than are reasonable with the intended design, expectations need to be set across the board, priming the team that performance goals are going to be paramount.</p>


	<h3>Communicating the performance impact during design phase</h3>

	<strong>Internally</strong>

	<p>During IA, IxD, and visual design, it is the front end engineer's role to communicate the performance impact of interactive features or certain visual techniques on the target browsers. Give the designers constraints: "If we're using Cufon, we cannot have more than 10 elements of custom font per page."</p>

	<strong>Externally</strong>

	<p>Expectations need to be set that <strong>all browsers will not have the same experience</strong>. They won't perform as well as each other, nor may it make sense to have feature parity. It may be sensible to drop a few features from the IE7 experience. Features that could be considered to be dropped are: <em>shadows, transitions, rounded corners, opacity, gradients.</em></p>
	
	<strong>When communicating the impact of something:</strong>

	<ul>
		<li>Clarify the impact with as much detail as possible: "it will hurt page load" vs "it will add 2 seconds to page load in IE"</li>
		<li>Provide a quick POC (proof of concept) if it's reasonable: "This similar-looking page without siFR loads in 2 seconds, with siFR it loads in 8 and has a delay to show during scrolling"</li>
	</ul>
	

	<h3>Develop according to best practices</h3>

	<p>Choose libraries and plugins that are performance optimized. Make wise architecture decisions based on performance goals. Also minimize DOM manipulation when possible, and write styles to <a href="http://paulirish.com/2009/avoiding-the-fouc-v3/">avoid visual changes</a> to the page as it loads and initializes.</p>


	<h3>Measure performance during QA</h3>

	<p>QA teams should also prioritize performance related tickets alongside visual, functional, and usability issues. Developers and QA should determine how that priority will be assigned. During QA, the success metrics should be tested regularly.</p>

	<strong>Tools to test with</strong>

	<ul>
		<li><a href="http://developer.yahoo.com/yslow/">YSlow</a>, <a href="http://code.google.com/speed/page-speed/">Page Speed</a>, <a href="http://stevesouders.com/hammerhead/">Hammerhead</a>, <a href="http://msfast.myspace.com/">MSFast</a>, <a href="http://www.webpagetest.org/">PageTest</a></li>
	</ul>

	<strong>When performance goals aren't met, there are three options:</strong>

	<ol>
		<li><em>Redevelop the code</em> - profile, discover bottlenecks, refactor code, optimize to target faster execution in the browser</li>
		<li><em>Drop the feature</em> - turn it off for slower browsers only</li>
		<li><em>Redesign approach of the UI</em> - perhaps the design could use a tweak which would bypass the issue entirely</li>
	</ol>

	<p>With this approach, we think all parties have a better chance of having aligned expectations heading in as well as a more sensible workflow in dealing with performance challenges.</p>


</section>